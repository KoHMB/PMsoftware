---
title: "Production model in JABBA"
author: "Kohei Hamabe"
date: "2021/8/5"
output: md_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(JABBA)
library(tidyverse)
dat <- readRDS("data/pol.rds")
output.dir <- "C:/Users/00007920/Desktop/GitHub_repository/PMsoftware"
```


# データ

`library(spict)`に内蔵のデータを使う

```{r}

par(mfrow=c(2,2))
# Albacore
plot(dat$albacore$timeC, dat$albacore$obsC, type = "h",
     lwd=2, col = "red", main = "Albacore", ylim = c(0, max(dat$albacore$obsC)),
     xlab = "Year", ylab = "Catch")
par(new=T)
plot(dat$albacore$timeI, dat$albacore$obsI, lwd=2,
     type = "l", lty = 2, yaxt = "n",
     xlab = "", ylab = "")
# Lobster
plot(dat$lobster$timeC, dat$lobster$obsC, type = "h",
     lwd=2, col = "red", main = "Lobster", ylim = c(0, max(dat$lobster$obsC)),
     xlab = "Year", ylab = "Catch")
par(new=T)
plot(dat$lobster$timeI, dat$lobster$obsI, lwd=2,
     type = "l", lty = 2, yaxt = "n",
     xlab = "", ylab = "")
# Hake
plot(dat$hake$timeC, dat$hake$obsC, type = "h",
     lwd=2, col = "red", main = "Hake", ylim = c(0, max(dat$hake$obsC)),
     xlab = "Year", ylab = "Catch")
par(new=T)
plot(dat$hake$timeI, dat$hake$obsI, lwd=2,
     type = "l", lty = 2, yaxt = "n",
     xlab = "", ylab = "")


```

- albacore
  - 意外に時系列が短い
  - 漁獲量はほぼ横ばい
  - CPUEは淡々と減少
  - => プロダクションモデルと相性良くない気がする
  
- lobster
  - `spict`データ内では一番時系列が長い
  - 漁獲量は55年にピークで、そこから少し減ってほぼ横這い
  - 85年からの5年ほどは漁獲量が減少傾向
  - CPUEは50年代はピーキー
  - 55年以降は単調減少
  - => CPUE減少、漁獲量一定は相性が悪いけど、時系列が長いのでやりやすいかも？
  
- hake
  - 時系列は23年と短めだけど十分推定はできると思う
  - 漁獲量も獲れる獲れないのコントラストが一番みられる
  - 漁獲量が落ち込む80年前後に併せて、CPUEも低位になる
  - 82年以降の漁獲量増加とともに、CPUEも上がっていく
  - => 増加の情報があって良いのではないか
  


# Example 1. Albacore

## とりあえず解析

### データの整理

```{r}

dat_albacore <- list(
  cpue = data.frame(Year = dat$albacore$timeI,
                    CPUE = dat$albacore$obsI),
  se = data.frame(Year = dat$albacore$timeI,
                  CPUE = rep(NA, length(dat$albacore$timeI))),
  catch = data.frame(Year = dat$albacore$timeC,
                     catch = dat$albacore$obsC)
  )

```


### 設定

```{r}

jbinput_albacore1 <-  build_jabba(
  catch = dat_albacore$catch,
  cpue = dat_albacore$cpue,
  se = dat_albacore$se,
  assessment="test_albacore",
  scenario = "TestRun",
  model.type = "Schaefer",
  add.catch.CV = FALSE,
  # prior sets
  r.dist = "lnorm",
  r.prior = c(0.5,1),
  K.dist = "lnorm",
  K.prior = c(10*max(dat_albacore$catch$catch), 1),
  psi.dist = "beta",
  psi.prior = c(0.05,0.9),
  # variance sets
  sigma.proc = TRUE,
  sigma.est = TRUE, # additional observation variance
  fixed.obsE = 0.)

```


### MCMCの実行


```{r}

fit_albacore1 <- fit_jabba(jbinput_albacore1, quickmcmc=TRUE)
fit_albacore1$estimates

```



### 結果の出力


```{r}

jbplot_catcherror(fit_albacore1)
jbplot_ppdist(fit_albacore1)
jbplot_cpuefits(fit_albacore1)
jbplot_logfits(fit_albacore1)

par(mfrow=c(3,2),mar = c(3.5, 3.5, 0.5, 0.1))
jbplot_trj(fit_albacore1,type="B",add=T)
jbplot_trj(fit_albacore1,type="F",add=T)
jbplot_trj(fit_albacore1,type="BBmsy",add=T)
jbplot_trj(fit_albacore1,type="FFmsy",add=T)
jbplot_spphase(fit_albacore1,add=T)
jbplot_kobe(fit_albacore1,add=T)

```


## 事前分布を無情報にしてみる

JABBAチュートリアルによると

- 増加率と環境収容力
  - `"range"`とあるが、一様分布の上下限というわけではなさそう
  - => 対数正規にした時の上下限のことらしい
  - `"lnorm"`で誤差を大きくするしかないか...
  
- 初期枯渇率`psi`はベータ分布だから一様にできる

```{r}

jbinput_albacore2 <-  build_jabba(
  catch = dat_albacore$catch,
  cpue = dat_albacore$cpue,
  se = dat_albacore$se,
  assessment="test_albacore",
  scenario = "TestRun",
  model.type = "Schaefer",
  add.catch.CV = FALSE,
  # prior sets
  r.dist = "lnorm",
  r.prior = c(0.5,2),
  K.dist = "lnorm",
  K.prior = c(10*max(dat_albacore$catch$catch), 10),
  psi.dist = "beta",
  psi.prior = c(1,1),
  # variance sets
  sigma.proc = TRUE,
  sigma.est = TRUE, # additional observation variance
  fixed.obsE = 0.)

```


### MCMCの実行


```{r}

fit_albacore2 <- fit_jabba(jbinput_albacore2) %>% try()

```


怒られた  
なんだか初期枯渇率`psi`が無限大なった的な  
データのせいなのか、JABBAの特性なのかは分からない


山形ダメだったので、窪地にしてみる
$$\alpha = 0.5, \beta = 0.5$$

初期枯渇率`psi`とか推定の難しそうなパラメータに対して、事前分布の恩恵が大きいんだろう



```{r}

jbinput_albacore2 <-  build_jabba(
  catch = dat_albacore$catch,
  cpue = dat_albacore$cpue,
  se = dat_albacore$se,
  assessment="test_albacore",
  scenario = "TestRun",
  model.type = "Schaefer",
  add.catch.CV = FALSE,
  # prior sets
  r.dist = "lnorm",
  r.prior = c(0.5,10),
  K.dist = "lnorm",
  K.prior = c(10*max(dat_albacore$catch$catch), 10),
  psi.dist = "beta",
  psi.prior = c(0.5,0.5),
  # variance sets
  sigma.proc = TRUE,
  sigma.est = TRUE, # additional observation variance
  fixed.obsE = 0.)

fit_albacore2 <- fit_jabba(jbinput_albacore2, quickmcmc = T) %>% try()

```


### 結果の出力


```{r}

jbplot_ppdist(fit_albacore2)
jbplot_cpuefits(fit_albacore2)
jbplot_logfits(fit_albacore2)

par(mfrow=c(3,2),mar = c(3.5, 3.5, 0.5, 0.1))
jbplot_trj(fit_albacore2,type="B",add=T)
jbplot_trj(fit_albacore2,type="F",add=T)
jbplot_trj(fit_albacore2,type="BBmsy",add=T)
jbplot_trj(fit_albacore2,type="FFmsy",add=T)
jbplot_spphase(fit_albacore2,add=T)
jbplot_kobe(fit_albacore2,add=T)

```



# Example 2. Lobster

一番時系列が長いlobsterのデータで解析してみる

```{r}

dat_lobster <- list(
  cpue = data.frame(Year = dat$lobster$timeI,
                    CPUE = dat$lobster$obsI),
  se = data.frame(Year = dat$lobster$timeI,
                  CPUE = rep(NA, length(dat$lobster$timeI))),
  catch = data.frame(Year = dat$lobster$timeC,
                     catch = dat$lobster$obsC)
  )

```


### 設定

```{r}

jbinput_lobster1 <-  build_jabba(
  catch = dat_lobster$catch,
  cpue = dat_lobster$cpue,
  se = dat_lobster$se,
  assessment="test_lobster",
  scenario = "TestRun",
  model.type = "Schaefer",
  add.catch.CV = FALSE,
  # prior sets
  r.dist = "lnorm",
  r.prior = c(0.5,1.5),
  K.dist = "lnorm",
  K.prior = c(max(dat_lobster$catch$catch), 5),
  psi.dist = "beta",
  psi.prior = c(0.5,0.5),
  # variance sets
  sigma.proc = TRUE,
  sigma.est = TRUE, # additional observation variance
  fixed.obsE = 0.)

```


### MCMCの実行


```{r}

fit_lobster1 <- fit_jabba(jbinput_lobster1, quickmcmc=TRUE)
fit_lobster1$pars
fit_lobster1$estimates

```



### 結果の出力


```{r}

jbplot_ppdist(fit_lobster1)
jbplot_cpuefits(fit_lobster1)
jbplot_logfits(fit_lobster1)

par(mfrow=c(3,2),mar = c(3.5, 3.5, 0.5, 0.1))
jbplot_trj(fit_lobster1,type="B",add=T)
jbplot_trj(fit_lobster1,type="F",add=T)
jbplot_trj(fit_lobster1,type="BBmsy",add=T)
jbplot_trj(fit_lobster1,type="FFmsy",add=T)
jbplot_spphase(fit_lobster1,add=T)
jbplot_kobe(fit_lobster1,add=T)

```



# Example 3. Hake

増加の情報がありそうなHakeのデータで解析してみる

```{r}

dat_hake <- list(
  cpue = data.frame(Year = dat$hake$timeI,
                    CPUE = dat$hake$obsI),
  se = data.frame(Year = dat$hake$timeI,
                  CPUE = rep(NA, length(dat$hake$timeI))),
  catch = data.frame(Year = dat$hake$timeC,
                     catch = dat$hake$obsC)
  )

```


### 設定

```{r}

jbinput_hake1 <-  build_jabba(
  catch = dat_hake$catch,
  cpue = dat_hake$cpue,
  se = dat_hake$se,
  assessment="test_hake",
  scenario = "TestRun",
  model.type = "Schaefer",
  add.catch.CV = FALSE,
  # prior sets
  r.dist = "lnorm",
  r.prior = c(0.5,1.5),
  K.dist = "lnorm",
  K.prior = c(max(dat_hake$catch$catch), 5),
  psi.dist = "beta",
  psi.prior = c(0.5,0.5),
  # variance sets
  sigma.proc = TRUE,
  sigma.est = TRUE, # additional observation variance
  fixed.obsE = 0.)

```


### MCMCの実行


```{r}

fit_hake1 <- fit_jabba(jbinput_hake1, quickmcmc=TRUE)
fit_hake1$estimates

```



### 結果の出力


```{r}

jbplot_ppdist(fit_hake1)
jbplot_cpuefits(fit_hake1)
jbplot_logfits(fit_hake1)

par(mfrow=c(3,2),mar = c(3.5, 3.5, 0.5, 0.1))
jbplot_trj(fit_hake1,type="B",add=T)
jbplot_trj(fit_hake1,type="F",add=T)
jbplot_trj(fit_hake1,type="BBmsy",add=T)
jbplot_trj(fit_hake1,type="FFmsy",add=T)
jbplot_spphase(fit_hake1,add=T)
jbplot_kobe(fit_hake1,add=T)

```


